---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/4/18 11:38
---
local BattleHitUnit = BaseClass("BattleHitUnit")
local DefaultDistance = 0.25
local DefaultTime = 0.2

local function __init(self, opId, skillCfg, result, callback)
    self.skillCfg = skillCfg
    self.resultType = BattleHitCommon
    self.endCallBack = callback
    self.resultUnit = result
    local battle = BattleManager:GetInstance():GetBattle()
    self.opId = opId
    self.aimId = result.targetId
    self.opBattler = battle:FindBattleById(self.opId)
    self.aimBattler = battle:FindBattleById(self.aimId)
    self.opCharacter = opBattler:GetCharacter()
    self.aimCharacter = aimBattler:GetCharacter()
    self.isMoveEnd = false;
    self.isStiffEnd = false
end

local function ShowHitUnit(self)
    --属性更新
    aimBattler:DealAttrWithBattleResult(self.resultUnit)
    local battle = BattleManager:GetInstance():GetBattle()
    --buff
    if (self.resultUnit.buffs) then
        for _, buff in pairs(self.resultUnit.buffs) do
            local battler = battle:FindBattlerByID(buff.fighterid)
            if battler then
                battler:GetBuffAgent():UpdateBuff(buff)
            end
        end
    end

    --受击动作
    local isCritic = false;
    local isDodge = false;
    local isDefence = false;

    local resultUnit = resultUnit
    for i = 1, BattleResult.eBattleResultMax do
        local result = CS.BitOperator.lMove(1, BattleResult.eBattleResultMax - i);
        if CS.BitOperator.And(result, resultUnit.eTargetResult) == result then
            if result == BattleResult.eBattleResultDefence then
                isDefence = true
            elseif result == BattleResult.eBattleResultDodge then
                isDodge = true
            elseif result == BattleResult.eBattleResultCritic then
                isCritic = true
            end
        end
    end

    if resultUnit.returnHurt ~= nil and resultUnit.returnHurt ~= 0 then
        self:ChangeHp(self.opCharacter, resultUnit.returnHurt, CHARACTER_POPUP_TYPE.HP)
    end

    if resultUnit.attackBack ~= nil and resultUnit.attackBack ~= 0 then
        self:ChangeHp(self.opCharacter, resultUnit.attackBack, CHARACTER_POPUP_TYPE.HP)
    end

    if isDefence then
        self:ChangeHp(self.aimCharacter, resultUnit.hpChange, CHARACTER_POPUP_TYPE.HP)
        self:PlayDefence()
    elseif isDodge then
        self:ChangeHp(self.aimCharacter, resultUnit.hpChange, CHARACTER_POPUP_TYPE.DODGE)
        self:PlayDodge()
    else
        if isCritic then
            local record = BattleSkillManager.GetSkillTypeConfigById(self.skillId)
            if record ~= nil then
                if record.damageType == SkillDamageType.Physics then
                    self:ChangeHp(self.aimCharacter, resultUnit.hpChange, CHARACTER_POPUP_TYPE.PHY_CRIT)
                else
                    self:ChangeHp(self.aimCharacter, resultUnit.hpChange, CHARACTER_POPUP_TYPE.SPELL_CRIT)
                end
            end
        else
            self:ChangeHp(self.aimCharacter, resultUnit.hpChange, CHARACTER_POPUP_TYPE.HP)
        end
        self:PlayNormal()
    end
end

--飘血的逻辑
local function ChangeHp(self, character, hpValue, popupType)
    if hpValue ~= nil or popupType == CHARACTER_POPUP_TYPE.DODGE then
        local skillAttr = UISkillAttr.New(character, UILayersA.GuiCamera_1_2.NAME)
        skillAttr:SetUISkillAttr(hpValue, popupType);
    end
end

local function PlayDefence(self)
    --todo 目标unit播放防御动作 目前没做防御这块 跟normal走
    self:PlayNormal()
end

local function PlayNormal(self)
    --受击动作
    if (self.resultUnit.hpChange and self.resultUnit.hpChange < 0) then
        local aimPos = self.aimCharacter:GetRealPos()
        local opPos = self.opCharacter:GetRealPos()
        self.aimCharacter:ChangeFace(FaceToUtils.GetFaceTo4(aimPos.x, aimPos.y, opPos.x, opPos.y, aimCharacter:FaceTo()))
        local action = require "Unit.Actions.StiffAction".New()
        self.aimBattler:PlayAction(action, false, BindCallback(self, self.TriggerActionUnitEnd))
        --移动
        self.defaultPos = aimPos
        local destpos = self.aimCharacter:GetPosByIdAndArrivePointType(BattleArrivePointType.Behind, DefaultDistance)
        self.aimCharacter:MoveByTime(destpos, DefaultTime, BindCallback(self, self.MoveBehindPositionEnd))
    else
        self:TriggerMoveEnd()
        self:TriggerActionUnitEnd()
    end
end

local function PlayDodge(self)
    this.triggerActionUnitEnd();--没有动作播放
    --移动 todo 没有判断增益 临时就判断伤血才会有闪避表现
    if (this.resultUnit.hpChange == nil or this.resultUnit.hpChange == 0) then
        local aimPos = self.aimCharacter:GetRealPos()
        local opPos = self.opCharacter:GetRealPos()
        self.aimCharacter:ChangeFace(FaceToUtils.GetFaceTo4(aimPos.x, aimPos.y, opPos.x, opPos.y, aimCharacter:FaceTo()))
        self.defaultPos = aimPos
        local pointType = math.random(2, 5)
        local destpos = self.aimCharacter:GetPosByIdAndArrivePointType(pointType, DefaultDistance)
        self.aimCharacter:MoveByTime(destpos, DefaultTime, BindCallback(self, self.MoveBehindPositionEnd))
    else
        self:TriggerMoveEnd()
    end

end

local function TriggerMoveEnd(self)
    self.isMoveEnd = true
    self:TryTriggerEnd()
end

local function TriggerActionUnitEnd(self)
    self.isStiffEnd = true
    self:TryTriggerEnd()
end

local function TryTriggerEnd(self)
    if (self.isStiffEnd and self.isMoveEnd) then
        self.aimBattler:DealActionWithBattleResult(self.resultUnit, self.endCallBack)
    end
end

BattleHitUnit.__init = __init
BattleHitUnit.ShowHitUnit = ShowHitUnit
BattleHitUnit.ChangeHp = ChangeHp
BattleHitUnit.PlayDefence = PlayDefence
BattleHitUnit.PlayDodge = PlayDodge
BattleHitUnit.PlayNormal = PlayNormal
BattleHitUnit.TriggerMoveEnd = TriggerMoveEnd
BattleHitUnit.TriggerActionUnitEnd = TriggerActionUnitEnd
BattleHitUnit.TryTriggerEnd = TryTriggerEnd
return BattleHitUnit